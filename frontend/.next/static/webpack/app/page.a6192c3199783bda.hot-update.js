"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/server_utils.js":
/*!*****************************!*\
  !*** ./lib/server_utils.js ***!
  \*****************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   acceptOffer: () => (/* binding */ acceptOffer),\n/* harmony export */   connectserver: () => (/* binding */ connectserver),\n/* harmony export */   createConnection: () => (/* binding */ createConnection),\n/* harmony export */   declineOffer: () => (/* binding */ declineOffer),\n/* harmony export */   getPeerId: () => (/* binding */ getPeerId),\n/* harmony export */   handleSignal: () => (/* binding */ handleSignal),\n/* harmony export */   sendChunk: () => (/* binding */ sendChunk),\n/* harmony export */   sendSignal: () => (/* binding */ sendSignal)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nlet localConnection;\nlet dataChannel;\nlet ws;\nlet pendingOffer;\nlet remotePeerId;\nlet pendingCandidates = [];\nconst peerId = Math.random().toString(36).substring(2, 10);\n// to display own peerid in frontend\nconst getPeerId = ()=>{\n    return peerId;\n};\nconst connectserver = (onSignalMessage, onStatusUpdate)=>{\n    ws = new WebSocket(process.env.NEXT_PUBLIC_SIGNALING_SERVER_URL || \"http://\".concat(window.location.host));\n    // registering peerid at the socket\n    ws.onopen = ()=>{\n        ws.send(JSON.stringify({\n            type: \"register\",\n            peerId\n        }));\n        console.log(\"WebSocket connected for \".concat(peerId));\n    };\n    // on message to the socket(ICE/offer/answer) we call the callback\n    ws.onmessage = (e)=>{\n        const msg = JSON.parse(e.data);\n        if (msg.type === \"signal\") {\n            onSignalMessage(msg.from, msg.data);\n        }\n        if (msg.type === \"answer\") {\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate(\"accepted\", msg.from);\n            onSignalMessage(msg.from, msg.data);\n        }\n        if (msg.type === \"decline\") {\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate(\"declined\", msg.from);\n        }\n        if (msg.type === \"error\") {\n            if ( true && window.showConnectionError) {\n                window.showConnectionError(msg.message);\n            }\n        }\n    };\n};\n// to send the signal to socket server\nconst sendSignal = (targetId, data)=>{\n    ws.send(JSON.stringify({\n        type: \"signal\",\n        target: targetId,\n        data\n    }));\n};\nconst createConnection = async (targetId, onData, onReady)=>{\n    remotePeerId = targetId;\n    localConnection = new RTCPeerConnection();\n    // setting up data channel for file transfer\n    dataChannel = localConnection.createDataChannel(\"file\");\n    dataChannel.binaryType = \"arraybuffer\";\n    dataChannel.onopen = ()=>{\n        console.log(\"DataChannel open between \".concat(peerId, \" and \").concat(remotePeerId));\n        onReady(true);\n    };\n    // on getting data through the channel\n    dataChannel.onmessage = (e)=>onData(e.data);\n    // when we get ICE we send the signal to the socket server\n    localConnection.onicecandidate = (e)=>{\n        if (e.candidate) {\n            sendSignal(targetId, {\n                candidate: e.candidate\n            });\n        }\n    };\n    // asking to connect\n    const offer = await localConnection.createOffer();\n    await localConnection.setLocalDescription(offer);\n    sendSignal(targetId, {\n        sdp: offer\n    });\n};\nconst handleSignal = async (from, data, onData, onOfferReceived)=>{\n    if (!localConnection) {\n        remotePeerId = from;\n        localConnection = new RTCPeerConnection();\n        // Receiving data channel\n        localConnection.ondatachannel = (event)=>{\n            dataChannel = event.channel;\n            dataChannel.binaryType = \"arraybuffer\";\n            dataChannel.onmessage = (e)=>onData(e.data);\n        };\n        // ICE gathering\n        localConnection.onicecandidate = (e)=>{\n            if (e.candidate) {\n                sendSignal(from, {\n                    candidate: e.candidate\n                });\n            }\n        };\n    }\n    // Handling offer\n    if (data.sdp && data.sdp.type === \"offer\") {\n        pendingOffer = {\n            from,\n            sdp: data.sdp\n        };\n        onOfferReceived(from);\n        return;\n    }\n    // Handling answer\n    if (data.sdp && data.sdp.type === \"answer\") {\n        await localConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));\n        for (const candidate of pendingCandidates){\n            await localConnection.addIceCandidate(new RTCIceCandidate(candidate));\n        }\n        pendingCandidates = [];\n        return;\n    }\n    // Handling ICE candidate\n    if (data.candidate) {\n        if (localConnection.remoteDescription && localConnection.remoteDescription.type) {\n            await localConnection.addIceCandidate(new RTCIceCandidate(data.candidate));\n        } else {\n            console.log(\"Queuing ICE candidate until remoteDescription is set.\");\n            pendingCandidates.push(data.candidate);\n        }\n    }\n};\nconst sendChunk = (chunk)=>{\n    if ((dataChannel === null || dataChannel === void 0 ? void 0 : dataChannel.readyState) === \"open\") {\n        dataChannel.send(chunk);\n    }\n};\nconst acceptOffer = async (from)=>{\n    if (!pendingOffer || pendingOffer.from !== from) return;\n    const remoteDesc = new RTCSessionDescription(pendingOffer.sdp);\n    await localConnection.setRemoteDescription(remoteDesc);\n    const answer = await localConnection.createAnswer();\n    await localConnection.setLocalDescription(answer);\n    sendSignal(pendingOffer.from, {\n        sdp: answer,\n        type: \"answer\"\n    });\n    pendingOffer = null;\n};\nconst declineOffer = (from)=>{\n    sendSignal(pendingOffer.from, {\n        type: \"decline\"\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTTFCLGdCQUFnQjJELGVBQWUsQ0FBQyxJQUFJQyxnQkFBZ0IzQixLQUFLYyxTQUFTO1FBQzVFLE9BQU87WUFDSHBCLFFBQVFDLEdBQUcsQ0FBQztZQUNadkIsa0JBQWtCeUQsSUFBSSxDQUFDN0IsS0FBS2MsU0FBUztRQUN6QztJQUNKO0FBQ0osRUFBRTtBQUdLLE1BQU1nQixZQUFZLENBQUNDO0lBQ3RCLElBQUkvRCxDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWFnRSxVQUFVLE1BQUssUUFBUTtRQUNwQ2hFLFlBQVlzQixJQUFJLENBQUN5QztJQUNyQjtBQUNKLEVBQUU7QUFFSyxNQUFNRSxjQUFjLE9BQU9oQztJQUM5QixJQUFJLENBQUMvQixnQkFBZ0JBLGFBQWErQixJQUFJLEtBQUtBLE1BQU07SUFFakQsTUFBTWlDLGFBQWEsSUFBSVQsc0JBQXNCdkQsYUFBYWdELEdBQUc7SUFDN0QsTUFBTW5ELGdCQUFnQnlELG9CQUFvQixDQUFDVTtJQUUzQyxNQUFNQyxTQUFTLE1BQU1wRSxnQkFBZ0JxRSxZQUFZO0lBQ2pELE1BQU1yRSxnQkFBZ0JrRCxtQkFBbUIsQ0FBQ2tCO0lBRTFDL0IsV0FBV2xDLGFBQWErQixJQUFJLEVBQUU7UUFDMUJpQixLQUFLaUI7UUFDTDFDLE1BQU07SUFDVjtJQUVBdkIsZUFBZTtBQUNuQixFQUFFO0FBRUssTUFBTW1FLGVBQWUsQ0FBQ3BDO0lBQ3pCRyxXQUFXbEMsYUFBYStCLElBQUksRUFBRTtRQUFFUixNQUFNO0lBQVU7QUFDcEQsRUFBRSIsInNvdXJjZXMiOlsiRDpcXFNhdmUgRmlsZXNcXFZpc3VhbCBTdHVkaW9cXFZvaWRTaGFyZVxcdm9pZHNoYXJlXFxmcm9udGVuZFxcbGliXFxzZXJ2ZXJfdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGxvY2FsQ29ubmVjdGlvbjtcclxubGV0IGRhdGFDaGFubmVsO1xyXG5sZXQgd3M7XHJcbmxldCBwZW5kaW5nT2ZmZXI7XHJcbmxldCByZW1vdGVQZWVySWQ7XHJcbmxldCBwZW5kaW5nQ2FuZGlkYXRlcyA9IFtdO1xyXG5cclxuY29uc3QgcGVlcklkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKTtcclxuXHJcbi8vIHRvIGRpc3BsYXkgb3duIHBlZXJpZCBpbiBmcm9udGVuZFxyXG5leHBvcnQgY29uc3QgZ2V0UGVlcklkID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIHBlZXJJZDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNvbm5lY3RzZXJ2ZXIgPSAob25TaWduYWxNZXNzYWdlLCBvblN0YXR1c1VwZGF0ZSkgPT4ge1xyXG4gICAgd3MgPSBuZXcgV2ViU29ja2V0KFxyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NJR05BTElOR19TRVJWRVJfVVJMIHx8IGBodHRwOi8vJHt3aW5kb3cubG9jYXRpb24uaG9zdH1gXHJcbiAgICApO1xyXG5cclxuICAgIC8vIHJlZ2lzdGVyaW5nIHBlZXJpZCBhdCB0aGUgc29ja2V0XHJcbiAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeSh7IHR5cGU6IFwicmVnaXN0ZXJcIiwgcGVlcklkIH0pKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgV2ViU29ja2V0IGNvbm5lY3RlZCBmb3IgJHtwZWVySWR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gb24gbWVzc2FnZSB0byB0aGUgc29ja2V0KElDRS9vZmZlci9hbnN3ZXIpIHdlIGNhbGwgdGhlIGNhbGxiYWNrXHJcbiAgICB3cy5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcclxuXHJcbiAgICAgICAgaWYgKG1zZy50eXBlID09PSBcInNpZ25hbFwiKSB7XHJcbiAgICAgICAgICAgIG9uU2lnbmFsTWVzc2FnZShtc2cuZnJvbSwgbXNnLmRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1zZy50eXBlID09PSBcImFuc3dlclwiKSB7XHJcbiAgICAgICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oXCJhY2NlcHRlZFwiLCBtc2cuZnJvbSk7XHJcbiAgICAgICAgICAgIG9uU2lnbmFsTWVzc2FnZShtc2cuZnJvbSwgbXNnLmRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1zZy50eXBlID09PSBcImRlY2xpbmVcIikge1xyXG4gICAgICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKFwiZGVjbGluZWRcIiwgbXNnLmZyb20pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1zZy50eXBlID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnNob3dDb25uZWN0aW9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5zaG93Q29ubmVjdGlvbkVycm9yKG1zZy5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG59XHJcblxyXG4vLyB0byBzZW5kIHRoZSBzaWduYWwgdG8gc29ja2V0IHNlcnZlclxyXG5leHBvcnQgY29uc3Qgc2VuZFNpZ25hbCA9ICh0YXJnZXRJZCwgZGF0YSkgPT4ge1xyXG4gICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgdHlwZTogXCJzaWduYWxcIixcclxuICAgICAgICB0YXJnZXQ6IHRhcmdldElkLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICB9KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVDb25uZWN0aW9uID0gYXN5bmMgKHRhcmdldElkLCBvbkRhdGEsIG9uUmVhZHkpID0+IHtcclxuICAgIHJlbW90ZVBlZXJJZCA9IHRhcmdldElkO1xyXG4gICAgbG9jYWxDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKCk7XHJcblxyXG4gICAgLy8gc2V0dGluZyB1cCBkYXRhIGNoYW5uZWwgZm9yIGZpbGUgdHJhbnNmZXJcclxuICAgIGRhdGFDaGFubmVsID0gbG9jYWxDb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKFwiZmlsZVwiKTtcclxuICAgIGRhdGFDaGFubmVsLmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcbiAgICBkYXRhQ2hhbm5lbC5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYERhdGFDaGFubmVsIG9wZW4gYmV0d2VlbiAke3BlZXJJZH0gYW5kICR7cmVtb3RlUGVlcklkfWApO1xyXG4gICAgICAgIG9uUmVhZHkodHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIG9uIGdldHRpbmcgZGF0YSB0aHJvdWdoIHRoZSBjaGFubmVsXHJcbiAgICBkYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSAoZSkgPT4gb25EYXRhKGUuZGF0YSk7XHJcblxyXG4gICAgLy8gd2hlbiB3ZSBnZXQgSUNFIHdlIHNlbmQgdGhlIHNpZ25hbCB0byB0aGUgc29ja2V0IHNlcnZlclxyXG4gICAgbG9jYWxDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKGUpID0+IHtcclxuICAgICAgICBpZiAoZS5jYW5kaWRhdGUpIHtcclxuICAgICAgICAgICAgc2VuZFNpZ25hbCh0YXJnZXRJZCwgeyBjYW5kaWRhdGU6IGUuY2FuZGlkYXRlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gYXNraW5nIHRvIGNvbm5lY3RcclxuICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgbG9jYWxDb25uZWN0aW9uLmNyZWF0ZU9mZmVyKCk7XHJcbiAgICBhd2FpdCBsb2NhbENvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XHJcbiAgICBzZW5kU2lnbmFsKHRhcmdldElkLCB7IHNkcDogb2ZmZXIgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaGFuZGxlU2lnbmFsID0gYXN5bmMgKGZyb20sIGRhdGEsIG9uRGF0YSwgb25PZmZlclJlY2VpdmVkKSA9PiB7XHJcbiAgICBpZiAoIWxvY2FsQ29ubmVjdGlvbikge1xyXG4gICAgICAgIHJlbW90ZVBlZXJJZCA9IGZyb207XHJcbiAgICAgICAgbG9jYWxDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKCk7XHJcblxyXG4gICAgICAgIC8vIFJlY2VpdmluZyBkYXRhIGNoYW5uZWxcclxuICAgICAgICBsb2NhbENvbm5lY3Rpb24ub25kYXRhY2hhbm5lbCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBkYXRhQ2hhbm5lbCA9IGV2ZW50LmNoYW5uZWw7XHJcbiAgICAgICAgICAgIGRhdGFDaGFubmVsLmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblxyXG4gICAgICAgICAgICBkYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSAoZSkgPT4gb25EYXRhKGUuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8vIElDRSBnYXRoZXJpbmdcclxuICAgICAgICBsb2NhbENvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5jYW5kaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHNlbmRTaWduYWwoZnJvbSwgeyBjYW5kaWRhdGU6IGUuY2FuZGlkYXRlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGluZyBvZmZlclxyXG4gICAgaWYgKGRhdGEuc2RwICYmIGRhdGEuc2RwLnR5cGUgPT09IFwib2ZmZXJcIikge1xyXG4gICAgICAgIHBlbmRpbmdPZmZlciA9IHsgZnJvbSwgc2RwOiBkYXRhLnNkcCB9O1xyXG4gICAgICAgIG9uT2ZmZXJSZWNlaXZlZChmcm9tKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxpbmcgYW5zd2VyXHJcbiAgICBpZiAoZGF0YS5zZHAgJiYgZGF0YS5zZHAudHlwZSA9PT0gXCJhbnN3ZXJcIikge1xyXG4gICAgICAgIGF3YWl0IGxvY2FsQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGRhdGEuc2RwKSk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHBlbmRpbmdDYW5kaWRhdGVzKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxpbmcgSUNFIGNhbmRpZGF0ZVxyXG4gICAgaWYgKGRhdGEuY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgaWYgKGxvY2FsQ29ubmVjdGlvbi5yZW1vdGVEZXNjcmlwdGlvbiAmJiBsb2NhbENvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb24udHlwZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBsb2NhbENvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoZGF0YS5jYW5kaWRhdGUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlF1ZXVpbmcgSUNFIGNhbmRpZGF0ZSB1bnRpbCByZW1vdGVEZXNjcmlwdGlvbiBpcyBzZXQuXCIpO1xyXG4gICAgICAgICAgICBwZW5kaW5nQ2FuZGlkYXRlcy5wdXNoKGRhdGEuY2FuZGlkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IHNlbmRDaHVuayA9IChjaHVuaykgPT4ge1xyXG4gICAgaWYgKGRhdGFDaGFubmVsPy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIikge1xyXG4gICAgICAgIGRhdGFDaGFubmVsLnNlbmQoY2h1bmspO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFjY2VwdE9mZmVyID0gYXN5bmMgKGZyb20pID0+IHtcclxuICAgIGlmICghcGVuZGluZ09mZmVyIHx8IHBlbmRpbmdPZmZlci5mcm9tICE9PSBmcm9tKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgcmVtb3RlRGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24ocGVuZGluZ09mZmVyLnNkcCk7XHJcbiAgICBhd2FpdCBsb2NhbENvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24ocmVtb3RlRGVzYyk7XHJcblxyXG4gICAgY29uc3QgYW5zd2VyID0gYXdhaXQgbG9jYWxDb25uZWN0aW9uLmNyZWF0ZUFuc3dlcigpO1xyXG4gICAgYXdhaXQgbG9jYWxDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcclxuXHJcbiAgICBzZW5kU2lnbmFsKHBlbmRpbmdPZmZlci5mcm9tLCB7XHJcbiAgICAgICAgc2RwOiBhbnN3ZXIsXHJcbiAgICAgICAgdHlwZTogXCJhbnN3ZXJcIixcclxuICAgIH0pO1xyXG5cclxuICAgIHBlbmRpbmdPZmZlciA9IG51bGw7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGVjbGluZU9mZmVyID0gKGZyb20pID0+IHtcclxuICAgIHNlbmRTaWduYWwocGVuZGluZ09mZmVyLmZyb20sIHsgdHlwZTogXCJkZWNsaW5lXCIgfSwpO1xyXG59O1xyXG4iXSwibmFtZXMiOlsibG9jYWxDb25uZWN0aW9uIiwiZGF0YUNoYW5uZWwiLCJ3cyIsInBlbmRpbmdPZmZlciIsInJlbW90ZVBlZXJJZCIsInBlbmRpbmdDYW5kaWRhdGVzIiwicGVlcklkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiZ2V0UGVlcklkIiwiY29ubmVjdHNlcnZlciIsIm9uU2lnbmFsTWVzc2FnZSIsIm9uU3RhdHVzVXBkYXRlIiwiV2ViU29ja2V0IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NJR05BTElOR19TRVJWRVJfVVJMIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0Iiwib25vcGVuIiwic2VuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0eXBlIiwiY29uc29sZSIsImxvZyIsIm9ubWVzc2FnZSIsImUiLCJtc2ciLCJwYXJzZSIsImRhdGEiLCJmcm9tIiwic2hvd0Nvbm5lY3Rpb25FcnJvciIsIm1lc3NhZ2UiLCJzZW5kU2lnbmFsIiwidGFyZ2V0SWQiLCJ0YXJnZXQiLCJjcmVhdGVDb25uZWN0aW9uIiwib25EYXRhIiwib25SZWFkeSIsIlJUQ1BlZXJDb25uZWN0aW9uIiwiY3JlYXRlRGF0YUNoYW5uZWwiLCJiaW5hcnlUeXBlIiwib25pY2VjYW5kaWRhdGUiLCJjYW5kaWRhdGUiLCJvZmZlciIsImNyZWF0ZU9mZmVyIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsInNkcCIsImhhbmRsZVNpZ25hbCIsIm9uT2ZmZXJSZWNlaXZlZCIsIm9uZGF0YWNoYW5uZWwiLCJldmVudCIsImNoYW5uZWwiLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsIlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiIsImFkZEljZUNhbmRpZGF0ZSIsIlJUQ0ljZUNhbmRpZGF0ZSIsInJlbW90ZURlc2NyaXB0aW9uIiwicHVzaCIsInNlbmRDaHVuayIsImNodW5rIiwicmVhZHlTdGF0ZSIsImFjY2VwdE9mZmVyIiwicmVtb3RlRGVzYyIsImFuc3dlciIsImNyZWF0ZUFuc3dlciIsImRlY2xpbmVPZmZlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/server_utils.js\n"));

/***/ })

});