"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/server_utils.js":
/*!*****************************!*\
  !*** ./lib/server_utils.js ***!
  \*****************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   acceptOffer: () => (/* binding */ acceptOffer),\n/* harmony export */   connectserver: () => (/* binding */ connectserver),\n/* harmony export */   createConnection: () => (/* binding */ createConnection),\n/* harmony export */   declineOffer: () => (/* binding */ declineOffer),\n/* harmony export */   getPeerId: () => (/* binding */ getPeerId),\n/* harmony export */   handleSignal: () => (/* binding */ handleSignal),\n/* harmony export */   sendChunk: () => (/* binding */ sendChunk),\n/* harmony export */   sendSignal: () => (/* binding */ sendSignal)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nlet localConnection;\nlet dataChannel;\nlet ws;\nlet pendingOffer;\nlet remotePeerId;\nlet pendingCandidates = [];\nconst peerId = Math.random().toString(36).substring(2, 10);\n// to display own peerid in frontend\nconst getPeerId = ()=>{\n    return peerId;\n};\nconst connectserver = (onSignalMessage, onStatusUpdate)=>{\n    ws = new WebSocket(process.env.NEXT_PUBLIC_SIGNALING_SERVER_URL || \"ws://\".concat(window.location.hostname, \":3001\"));\n    // registering peerid at the socket\n    ws.onopen = ()=>{\n        ws.send(JSON.stringify({\n            type: \"register\",\n            peerId\n        }));\n        console.log(\"WebSocket connected for \".concat(peerId));\n    };\n    // on message to the socket(ICE/offer/answer) we call the callback\n    ws.onmessage = (e)=>{\n        const msg = JSON.parse(e.data);\n        if (msg.type === \"signal\") {\n            onSignalMessage(msg.from, msg.data);\n        }\n        if (msg.type === \"answer\") {\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate(\"accepted\", msg.from);\n            onSignalMessage(msg.from, msg.data);\n        }\n        if (msg.type === \"decline\") {\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate(\"declined\", msg.from);\n        }\n        if (msg.type === \"error\") {\n            if ( true && window.showConnectionError) {\n                window.showConnectionError(msg.message);\n            }\n        }\n    };\n};\n// to send the signal to socket server\nconst sendSignal = (targetId, data)=>{\n    ws.send(JSON.stringify({\n        type: \"signal\",\n        target: targetId,\n        data\n    }));\n};\nconst createConnection = async (targetId, onData, onReady)=>{\n    remotePeerId = targetId;\n    localConnection = new RTCPeerConnection();\n    // setting up data channel for file transfer\n    dataChannel = localConnection.createDataChannel(\"file\");\n    dataChannel.binaryType = \"arraybuffer\";\n    dataChannel.onopen = ()=>{\n        console.log(\"DataChannel open between \".concat(peerId, \" and \").concat(remotePeerId));\n        onReady(true);\n    };\n    // on getting data through the channel\n    dataChannel.onmessage = (e)=>onData(e.data);\n    // when we get ICE we send the signal to the socket server\n    localConnection.onicecandidate = (e)=>{\n        if (e.candidate) {\n            sendSignal(targetId, {\n                candidate: e.candidate\n            });\n        }\n    };\n    // asking to connect\n    const offer = await localConnection.createOffer();\n    await localConnection.setLocalDescription(offer);\n    sendSignal(targetId, {\n        sdp: offer\n    });\n};\nconst handleSignal = async (from, data, onData, onOfferReceived)=>{\n    if (!localConnection) {\n        remotePeerId = from;\n        localConnection = new RTCPeerConnection();\n        // Receiving data channel\n        localConnection.ondatachannel = (event)=>{\n            dataChannel = event.channel;\n            dataChannel.binaryType = \"arraybuffer\";\n            dataChannel.onmessage = (e)=>onData(e.data);\n        };\n        // ICE gathering\n        localConnection.onicecandidate = (e)=>{\n            if (e.candidate) {\n                sendSignal(from, {\n                    candidate: e.candidate\n                });\n            }\n        };\n    }\n    // Handling offer\n    if (data.sdp && data.sdp.type === \"offer\") {\n        pendingOffer = {\n            from,\n            sdp: data.sdp\n        };\n        onOfferReceived(from);\n        return;\n    }\n    // Handling answer\n    if (data.sdp && data.sdp.type === \"answer\") {\n        await localConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));\n        for (const candidate of pendingCandidates){\n            await localConnection.addIceCandidate(new RTCIceCandidate(candidate));\n        }\n        pendingCandidates = [];\n        return;\n    }\n    // Handling ICE candidate\n    if (data.candidate) {\n        if (localConnection.remoteDescription && localConnection.remoteDescription.type) {\n            await localConnection.addIceCandidate(new RTCIceCandidate(data.candidate));\n        } else {\n            console.log(\"Queuing ICE candidate until remoteDescription is set.\");\n            pendingCandidates.push(data.candidate);\n        }\n    }\n};\nconst sendChunk = (chunk)=>{\n    if ((dataChannel === null || dataChannel === void 0 ? void 0 : dataChannel.readyState) === \"open\") {\n        dataChannel.send(chunk);\n    }\n};\nconst acceptOffer = async (from)=>{\n    if (!pendingOffer || pendingOffer.from !== from) return;\n    const remoteDesc = new RTCSessionDescription(pendingOffer.sdp);\n    await localConnection.setRemoteDescription(remoteDesc);\n    const answer = await localConnection.createAnswer();\n    await localConnection.setLocalDescription(answer);\n    sendSignal(pendingOffer.from, {\n        sdp: answer,\n        type: \"answer\"\n    });\n    pendingOffer = null;\n};\nconst declineOffer = (from)=>{\n    sendSignal(pendingOffer.from, {\n        type: \"decline\"\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM3RSxNQUFNMUIsZ0JBQWdCMkQsZUFBZSxDQUFDLElBQUlDLGdCQUFnQjNCLEtBQUtjLFNBQVM7UUFDNUUsT0FBTztZQUNIcEIsUUFBUUMsR0FBRyxDQUFDO1lBQ1p2QixrQkFBa0J5RCxJQUFJLENBQUM3QixLQUFLYyxTQUFTO1FBQ3pDO0lBQ0o7QUFDSixFQUFFO0FBR0ssTUFBTWdCLFlBQVksQ0FBQ0M7SUFDdEIsSUFBSS9ELENBQUFBLHdCQUFBQSxrQ0FBQUEsWUFBYWdFLFVBQVUsTUFBSyxRQUFRO1FBQ3BDaEUsWUFBWXNCLElBQUksQ0FBQ3lDO0lBQ3JCO0FBQ0osRUFBRTtBQUVLLE1BQU1FLGNBQWMsT0FBT2hDO0lBQzlCLElBQUksQ0FBQy9CLGdCQUFnQkEsYUFBYStCLElBQUksS0FBS0EsTUFBTTtJQUVqRCxNQUFNaUMsYUFBYSxJQUFJVCxzQkFBc0J2RCxhQUFhZ0QsR0FBRztJQUM3RCxNQUFNbkQsZ0JBQWdCeUQsb0JBQW9CLENBQUNVO0lBRTNDLE1BQU1DLFNBQVMsTUFBTXBFLGdCQUFnQnFFLFlBQVk7SUFDakQsTUFBTXJFLGdCQUFnQmtELG1CQUFtQixDQUFDa0I7SUFFMUMvQixXQUFXbEMsYUFBYStCLElBQUksRUFBRTtRQUMxQmlCLEtBQUtpQjtRQUNMMUMsTUFBTTtJQUNWO0lBRUF2QixlQUFlO0FBQ25CLEVBQUU7QUFFSyxNQUFNbUUsZUFBZSxDQUFDcEM7SUFDekJHLFdBQVdsQyxhQUFhK0IsSUFBSSxFQUFFO1FBQUVSLE1BQU07SUFBVTtBQUNwRCxFQUFFIiwic291cmNlcyI6WyJEOlxcU2F2ZSBGaWxlc1xcVmlzdWFsIFN0dWRpb1xcVm9pZFNoYXJlXFx2b2lkc2hhcmVcXGZyb250ZW5kXFxsaWJcXHNlcnZlcl91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgbG9jYWxDb25uZWN0aW9uO1xyXG5sZXQgZGF0YUNoYW5uZWw7XHJcbmxldCB3cztcclxubGV0IHBlbmRpbmdPZmZlcjtcclxubGV0IHJlbW90ZVBlZXJJZDtcclxubGV0IHBlbmRpbmdDYW5kaWRhdGVzID0gW107XHJcblxyXG5jb25zdCBwZWVySWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xyXG5cclxuLy8gdG8gZGlzcGxheSBvd24gcGVlcmlkIGluIGZyb250ZW5kXHJcbmV4cG9ydCBjb25zdCBnZXRQZWVySWQgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gcGVlcklkO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY29ubmVjdHNlcnZlciA9IChvblNpZ25hbE1lc3NhZ2UsIG9uU3RhdHVzVXBkYXRlKSA9PiB7XHJcbiAgICB3cyA9IG5ldyBXZWJTb2NrZXQoXHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU0lHTkFMSU5HX1NFUlZFUl9VUkwgfHwgYHdzOi8vJHt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWV9OjMwMDFgXHJcbiAgICApO1xyXG5cclxuICAgIC8vIHJlZ2lzdGVyaW5nIHBlZXJpZCBhdCB0aGUgc29ja2V0XHJcbiAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeSh7IHR5cGU6IFwicmVnaXN0ZXJcIiwgcGVlcklkIH0pKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgV2ViU29ja2V0IGNvbm5lY3RlZCBmb3IgJHtwZWVySWR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gb24gbWVzc2FnZSB0byB0aGUgc29ja2V0KElDRS9vZmZlci9hbnN3ZXIpIHdlIGNhbGwgdGhlIGNhbGxiYWNrXHJcbiAgICB3cy5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcclxuXHJcbiAgICAgICAgaWYgKG1zZy50eXBlID09PSBcInNpZ25hbFwiKSB7XHJcbiAgICAgICAgICAgIG9uU2lnbmFsTWVzc2FnZShtc2cuZnJvbSwgbXNnLmRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1zZy50eXBlID09PSBcImFuc3dlclwiKSB7XHJcbiAgICAgICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oXCJhY2NlcHRlZFwiLCBtc2cuZnJvbSk7XHJcbiAgICAgICAgICAgIG9uU2lnbmFsTWVzc2FnZShtc2cuZnJvbSwgbXNnLmRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1zZy50eXBlID09PSBcImRlY2xpbmVcIikge1xyXG4gICAgICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKFwiZGVjbGluZWRcIiwgbXNnLmZyb20pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1zZy50eXBlID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnNob3dDb25uZWN0aW9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5zaG93Q29ubmVjdGlvbkVycm9yKG1zZy5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG59XHJcblxyXG4vLyB0byBzZW5kIHRoZSBzaWduYWwgdG8gc29ja2V0IHNlcnZlclxyXG5leHBvcnQgY29uc3Qgc2VuZFNpZ25hbCA9ICh0YXJnZXRJZCwgZGF0YSkgPT4ge1xyXG4gICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgdHlwZTogXCJzaWduYWxcIixcclxuICAgICAgICB0YXJnZXQ6IHRhcmdldElkLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICB9KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVDb25uZWN0aW9uID0gYXN5bmMgKHRhcmdldElkLCBvbkRhdGEsIG9uUmVhZHkpID0+IHtcclxuICAgIHJlbW90ZVBlZXJJZCA9IHRhcmdldElkO1xyXG4gICAgbG9jYWxDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKCk7XHJcblxyXG4gICAgLy8gc2V0dGluZyB1cCBkYXRhIGNoYW5uZWwgZm9yIGZpbGUgdHJhbnNmZXJcclxuICAgIGRhdGFDaGFubmVsID0gbG9jYWxDb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKFwiZmlsZVwiKTtcclxuICAgIGRhdGFDaGFubmVsLmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcbiAgICBkYXRhQ2hhbm5lbC5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYERhdGFDaGFubmVsIG9wZW4gYmV0d2VlbiAke3BlZXJJZH0gYW5kICR7cmVtb3RlUGVlcklkfWApO1xyXG4gICAgICAgIG9uUmVhZHkodHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIG9uIGdldHRpbmcgZGF0YSB0aHJvdWdoIHRoZSBjaGFubmVsXHJcbiAgICBkYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSAoZSkgPT4gb25EYXRhKGUuZGF0YSk7XHJcblxyXG4gICAgLy8gd2hlbiB3ZSBnZXQgSUNFIHdlIHNlbmQgdGhlIHNpZ25hbCB0byB0aGUgc29ja2V0IHNlcnZlclxyXG4gICAgbG9jYWxDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKGUpID0+IHtcclxuICAgICAgICBpZiAoZS5jYW5kaWRhdGUpIHtcclxuICAgICAgICAgICAgc2VuZFNpZ25hbCh0YXJnZXRJZCwgeyBjYW5kaWRhdGU6IGUuY2FuZGlkYXRlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gYXNraW5nIHRvIGNvbm5lY3RcclxuICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgbG9jYWxDb25uZWN0aW9uLmNyZWF0ZU9mZmVyKCk7XHJcbiAgICBhd2FpdCBsb2NhbENvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XHJcbiAgICBzZW5kU2lnbmFsKHRhcmdldElkLCB7IHNkcDogb2ZmZXIgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaGFuZGxlU2lnbmFsID0gYXN5bmMgKGZyb20sIGRhdGEsIG9uRGF0YSwgb25PZmZlclJlY2VpdmVkKSA9PiB7XHJcbiAgICBpZiAoIWxvY2FsQ29ubmVjdGlvbikge1xyXG4gICAgICAgIHJlbW90ZVBlZXJJZCA9IGZyb207XHJcbiAgICAgICAgbG9jYWxDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKCk7XHJcblxyXG4gICAgICAgIC8vIFJlY2VpdmluZyBkYXRhIGNoYW5uZWxcclxuICAgICAgICBsb2NhbENvbm5lY3Rpb24ub25kYXRhY2hhbm5lbCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBkYXRhQ2hhbm5lbCA9IGV2ZW50LmNoYW5uZWw7XHJcbiAgICAgICAgICAgIGRhdGFDaGFubmVsLmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblxyXG4gICAgICAgICAgICBkYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSAoZSkgPT4gb25EYXRhKGUuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8vIElDRSBnYXRoZXJpbmdcclxuICAgICAgICBsb2NhbENvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5jYW5kaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHNlbmRTaWduYWwoZnJvbSwgeyBjYW5kaWRhdGU6IGUuY2FuZGlkYXRlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGluZyBvZmZlclxyXG4gICAgaWYgKGRhdGEuc2RwICYmIGRhdGEuc2RwLnR5cGUgPT09IFwib2ZmZXJcIikge1xyXG4gICAgICAgIHBlbmRpbmdPZmZlciA9IHsgZnJvbSwgc2RwOiBkYXRhLnNkcCB9O1xyXG4gICAgICAgIG9uT2ZmZXJSZWNlaXZlZChmcm9tKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxpbmcgYW5zd2VyXHJcbiAgICBpZiAoZGF0YS5zZHAgJiYgZGF0YS5zZHAudHlwZSA9PT0gXCJhbnN3ZXJcIikge1xyXG4gICAgICAgIGF3YWl0IGxvY2FsQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGRhdGEuc2RwKSk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHBlbmRpbmdDYW5kaWRhdGVzKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxpbmcgSUNFIGNhbmRpZGF0ZVxyXG4gICAgaWYgKGRhdGEuY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgaWYgKGxvY2FsQ29ubmVjdGlvbi5yZW1vdGVEZXNjcmlwdGlvbiAmJiBsb2NhbENvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb24udHlwZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBsb2NhbENvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoZGF0YS5jYW5kaWRhdGUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlF1ZXVpbmcgSUNFIGNhbmRpZGF0ZSB1bnRpbCByZW1vdGVEZXNjcmlwdGlvbiBpcyBzZXQuXCIpO1xyXG4gICAgICAgICAgICBwZW5kaW5nQ2FuZGlkYXRlcy5wdXNoKGRhdGEuY2FuZGlkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IHNlbmRDaHVuayA9IChjaHVuaykgPT4ge1xyXG4gICAgaWYgKGRhdGFDaGFubmVsPy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIikge1xyXG4gICAgICAgIGRhdGFDaGFubmVsLnNlbmQoY2h1bmspO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFjY2VwdE9mZmVyID0gYXN5bmMgKGZyb20pID0+IHtcclxuICAgIGlmICghcGVuZGluZ09mZmVyIHx8IHBlbmRpbmdPZmZlci5mcm9tICE9PSBmcm9tKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgcmVtb3RlRGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24ocGVuZGluZ09mZmVyLnNkcCk7XHJcbiAgICBhd2FpdCBsb2NhbENvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24ocmVtb3RlRGVzYyk7XHJcblxyXG4gICAgY29uc3QgYW5zd2VyID0gYXdhaXQgbG9jYWxDb25uZWN0aW9uLmNyZWF0ZUFuc3dlcigpO1xyXG4gICAgYXdhaXQgbG9jYWxDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcclxuXHJcbiAgICBzZW5kU2lnbmFsKHBlbmRpbmdPZmZlci5mcm9tLCB7XHJcbiAgICAgICAgc2RwOiBhbnN3ZXIsXHJcbiAgICAgICAgdHlwZTogXCJhbnN3ZXJcIixcclxuICAgIH0pO1xyXG5cclxuICAgIHBlbmRpbmdPZmZlciA9IG51bGw7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGVjbGluZU9mZmVyID0gKGZyb20pID0+IHtcclxuICAgIHNlbmRTaWduYWwocGVuZGluZ09mZmVyLmZyb20sIHsgdHlwZTogXCJkZWNsaW5lXCIgfSwpO1xyXG59O1xyXG4iXSwibmFtZXMiOlsibG9jYWxDb25uZWN0aW9uIiwiZGF0YUNoYW5uZWwiLCJ3cyIsInBlbmRpbmdPZmZlciIsInJlbW90ZVBlZXJJZCIsInBlbmRpbmdDYW5kaWRhdGVzIiwicGVlcklkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiZ2V0UGVlcklkIiwiY29ubmVjdHNlcnZlciIsIm9uU2lnbmFsTWVzc2FnZSIsIm9uU3RhdHVzVXBkYXRlIiwiV2ViU29ja2V0IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NJR05BTElOR19TRVJWRVJfVVJMIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0bmFtZSIsIm9ub3BlbiIsInNlbmQiLCJKU09OIiwic3RyaW5naWZ5IiwidHlwZSIsImNvbnNvbGUiLCJsb2ciLCJvbm1lc3NhZ2UiLCJlIiwibXNnIiwicGFyc2UiLCJkYXRhIiwiZnJvbSIsInNob3dDb25uZWN0aW9uRXJyb3IiLCJtZXNzYWdlIiwic2VuZFNpZ25hbCIsInRhcmdldElkIiwidGFyZ2V0IiwiY3JlYXRlQ29ubmVjdGlvbiIsIm9uRGF0YSIsIm9uUmVhZHkiLCJSVENQZWVyQ29ubmVjdGlvbiIsImNyZWF0ZURhdGFDaGFubmVsIiwiYmluYXJ5VHlwZSIsIm9uaWNlY2FuZGlkYXRlIiwiY2FuZGlkYXRlIiwib2ZmZXIiLCJjcmVhdGVPZmZlciIsInNldExvY2FsRGVzY3JpcHRpb24iLCJzZHAiLCJoYW5kbGVTaWduYWwiLCJvbk9mZmVyUmVjZWl2ZWQiLCJvbmRhdGFjaGFubmVsIiwiZXZlbnQiLCJjaGFubmVsIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJhZGRJY2VDYW5kaWRhdGUiLCJSVENJY2VDYW5kaWRhdGUiLCJyZW1vdGVEZXNjcmlwdGlvbiIsInB1c2giLCJzZW5kQ2h1bmsiLCJjaHVuayIsInJlYWR5U3RhdGUiLCJhY2NlcHRPZmZlciIsInJlbW90ZURlc2MiLCJhbnN3ZXIiLCJjcmVhdGVBbnN3ZXIiLCJkZWNsaW5lT2ZmZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/server_utils.js\n"));

/***/ })

});